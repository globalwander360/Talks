Got it — you already have the table data loading fine, and now you want to add an "Export to Excel" feature that:

1. Calls your backend API with the same filters / pagination (but possibly full dataset for export).


2. Passes query parameters in RSQL format.


3. Is reusable so you can also use it in other components (not just Audit).



Here’s how I’d approach it step-by-step:


---

1. Create a Reusable Excel Export Service

We’ll make a service method that:

Builds the RSQL query string.

Calls the backend endpoint.

Downloads the Excel file.


export.service.ts

import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class ExportService {

  constructor(private http: HttpClient) {}

  /**
   * Export data as Excel file
   * @param endpoint API endpoint for export
   * @param rsqlQuery RSQL query string
   * @param fileName Name of the downloaded file
   */
  exportToExcel(endpoint: string, rsqlQuery: string, fileName: string) {
    const url = `${endpoint}?query=${encodeURIComponent(rsqlQuery)}`;
    this.http.get(url, { responseType: 'blob' }).subscribe(blob => {
      const downloadUrl = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = downloadUrl;
      link.download = fileName;
      link.click();
      window.URL.revokeObjectURL(downloadUrl);
    });
  }
}


---

2. Generate RSQL from Current Filters

When the user clicks Export, you need to build the RSQL string from:

eventId

Any other search filters applied in the table.


Example helper function:

rsql.utils.ts

export function buildAuditRsql(eventId: string, additionalFilters: any = {}): string {
  let filters = [`eventId==${eventId}`];

  if (additionalFilters.status) {
    filters.push(`status==${additionalFilters.status}`);
  }

  if (additionalFilters.dateFrom && additionalFilters.dateTo) {
    filters.push(`createdDate=ge=${additionalFilters.dateFrom};createdDate=le=${additionalFilters.dateTo}`);
  }

  return filters.join(';');
}


---

3. Integrate in Your Component

Now we use the reusable service + RSQL builder.

audit.component.ts

import { Component, OnInit } from '@angular/core';
import { auditHeader } from '../../config/audit-header.config';
import { ActivatedRoute } from '@angular/router';
import { Subject } from 'rxjs';
import { InitiatEventDataService } from 'app/initiate-event/shared/initiate-event-data.service';
import { ExportService } from 'app/shared/services/export.service';
import { buildAuditRsql } from 'app/shared/utils/rsql.utils';

@Component({
  selector: 'dpw-audit',
  templateUrl: './audit.component.html',
  styleUrls: ['./audit.component.scss']
})
export class AuditComponent implements OnInit {

  audits = [];
  totalCount;
  header = auditHeader;
  private _eventId;
  eventIdChanged$ = new Subject();

  constructor(
    private route: ActivatedRoute,
    private initiateEventDataService: InitiatEventDataService,
    private exportService: ExportService
  ) {
    this.route.params.subscribe(params => {
      this.eventId = params.eventId;
    });
  }

  public get eventId() {
    return this._eventId;
  }

  public set eventId(value) {
    this._eventId = value;
    this.eventIdChanged$.next(value);
  }

  ngOnInit(): void {
    this.eventIdChanged$.subscribe(() => {
      this.getAudits();
    });
  }

  onLoadData(pagination) {
    const { first, rows } = pagination;
    this.getAudits(first, rows);
  }

  getAudits(skip?, take?) {
    const params = { skip, take, eventId: this.eventId };
    this.initiateEventDataService.getAuditListByEventId(params).subscribe((auditsLisPage: any) => {
      const { count, results } = auditsLisPage;
      this.totalCount = count;
      this.audits = results;
    });
  }

  exportAudits() {
    const rsql = buildAuditRsql(this.eventId);
    const endpoint = '/api/audits/export'; // your backend export endpoint
    this.exportService.exportToExcel(endpoint, rsql, `audits-${this.eventId}.xlsx`);
  }
}


---

4. Update Template

<div class="alignExport">
  <p-button 
    label="Export To Excel" 
    severity="secondary" 
    (onClick)="exportAudits()">
  </p-button>
</div>

<dpw-table 
  [data]="audits" 
  [totalCount]="totalCount" 
  (loadData)="onLoadData($event)" 
  [header]="header">
</dpw-table>


---

5. How It Works

Table loading → still uses getAudits() with pagination.

Export button click:

Builds an RSQL string from current filters.

Calls export API with full dataset (no pagination).

Downloads file as Excel.




---

If you want, I can also make this completely generic so any component can pass in filters, endpoint, and file name without writing custom logic every time. That way your "other section" can use the same exportToExcel with minimal changes.

Do you want me to make that reusable generic version? That way you won’t duplicate code at all.

private static final String CUSTOMER_NAME = "Customer Name: ";
    private static final String CUSTOMER_ID = "Customer ID: ";
    private static final String PRODUCT_GROUP = "Product Group: ";
    private static final String PRODUCT = "Product: ";
    private static final String EVENT = "Event: ";
    private static final String EVENT_PRIORITY = "Event priority: ";
    private static final String EVENT_INITIATION = "Event Initiation: ";
    private static final String SPECIAL_INSTRUCTION = "Special Instruction: ";

    // Limits
    private static final int MAX_HEADER_VALUE_LENGTH = 50;
    private static final int MAX_COMMENT_LENGTH = 1200;
    private static final int CHUNK_SIZE = 400;
    private static final String MASK_SUFFIX = "***";

    @Value("${event.coversheet.spacing.betweenproperties}")
    private String betweenProperties;

    @Value("${event.coversheet.spacing.afterheader}")
    private String afterHeader;

    @Value("${event.coversheet.spacing.beforefooter}")
    private String beforeFooter;

    @Value("${event.coversheet.spacing.betweenparagraph}")
    private String betweenParagraph;

    @Value("${event.coversheet.font.keysize}")
    private String keySize;

    @Value("${event.coversheet.font.valuesize}")
    private String valueSize;

    @Value("${event.coversheet.font.keyfont}")
    private String keyFontProp;

    @Value("${event.coversheet.font.valuefont}")
    private String valueFontProp;

    @Value("${event.coversheet.alignment.left}")
    private String alignmentLeft;

    @Value("${event.coversheet.alignment.right}")
    private String alignmentRight;

    @Value("${event.coversheet.alignment.bottom}")
    private String alignmentBottom;

    @Autowired
    private SpecialInstructionsRepository specialInstructionsRepository;

    private class HeaderFooter extends PdfPageEventHelper {
        private RequestEvent requestEvent;
        private Font keyFont;
        private Font valueFont;

        public HeaderFooter(RequestEvent requestEvent, Font keyFont, Font valueFont) {
            this.requestEvent = requestEvent;
            this.keyFont = keyFont;
            this.valueFont = valueFont;
        }

        @Override
        public void onEndPage(PdfWriter writer, Document document) {
            PdfContentByte cb = writer.getDirectContent();
            float rightX = document.right();
            float headerY = document.getPageSize().getHeight() - 30;
            float lineSpacing = 22f;
            float availableWidth = document.right() - document.left();

            headerY = drawHeaderField(cb, MFR, maskValue(getOrDefault(requestEvent.getMfr())),
                    keyFont, valueFont, rightX, headerY, availableWidth);

            headerY = drawHeaderField(cb, UMFR, maskValue(getOrDefault(requestEvent.getUmfr())),
                    keyFont, valueFont, rightX, headerY - lineSpacing, availableWidth);

            headerY = drawHeaderField(cb, EVENTID, maskValue(getOrDefault(requestEvent.getId())),
                    keyFont, valueFont, rightX, headerY - lineSpacing, availableWidth);

            headerY = drawHeaderField(cb, CUSTOMER_ID, maskValue(getOrDefault(requestEvent.getCustId())),
                    keyFont, valueFont, rightX, headerY - lineSpacing, availableWidth);

            headerY = drawHeaderField(cb, CUSTOMER_NAME, maskValue(getOrDefault(requestEvent.getCusName())),
                    keyFont, valueFont, rightX, headerY - lineSpacing, availableWidth);
        }

        private float drawHeaderField(PdfContentByte cb, String label, String value, Font keyFont,
                                      Font valueFont, float rightX, float y, float availableWidth) {

            float labelWidth = keyFont.getBaseFont().getWidthPoint(label, keyFont.getSize());
            float valueWidth = valueFont.getBaseFont().getWidthPoint(value, valueFont.getSize());
            float totalWidth = labelWidth + valueWidth;

            if (totalWidth <= availableWidth) {
                float startX = rightX - totalWidth;
                drawText(cb, label, keyFont, startX, y);
                drawText(cb, value, valueFont, startX + labelWidth, y);
                return y;
            } else {
                float labelStartX = rightX - labelWidth;
                drawText(cb, label, keyFont, labelStartX, y);
                float valueY = y - 15f;
                drawText(cb, value, valueFont, document.left(), valueY);
                return valueY;
            }
        }

        private void drawText(PdfContentByte cb, String text, Font font, float x, float y) {
            cb.beginText();
            cb.setFontAndSize(font.getBaseFont(), font.getSize());
            cb.setTextMatrix(x, y);
            cb.showText(text);
            cb.endText();
        }

        private String maskValue(String value) {
            if (value == null || value.equals("-") || value.length() <= MAX_HEADER_VALUE_LENGTH) {
                return value;
            }
            int visibleLength = MAX_HEADER_VALUE_LENGTH - MASK_SUFFIX.length();
            return value.substring(0, visibleLength) + MASK_SUFFIX;
        }

        private String getOrDefault(String str) {
            return (str == null || str.trim().isEmpty()) ? "-" : str;
        }
    }

    public byte[] export(RequestEvent requestEvent) throws DocumentException, IOException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        Document document = new Document(PageSize.A4);
        document.setMargins(36, 36, 140, 36);

        PdfWriter writer = PdfWriter.getInstance(document, byteArrayOutputStream);

        Font keyFont = FontFactory.getFont(keyFontProp);
        keyFont.setSize(Float.parseFloat(keySize));

        Font valueFont = FontFactory.getFont(valueFontProp);
        valueFont.setSize(Float.parseFloat(valueSize));

        writer.setPageEvent(new HeaderFooter(requestEvent, keyFont, valueFont));

        document.open();

        addProperty(document, PRODUCT_GROUP, requestEvent.getProductGroupName(), keyFont, valueFont);
        addProperty(document, PRODUCT, requestEvent.getProductName(), keyFont, valueFont);
        addProperty(document, EVENT, requestEvent.getEventName(), keyFont, valueFont);
        addProperty(document, EVENT_PRIORITY, requestEvent.getEventPriorityName(), keyFont, valueFont);

        String initiationDate = dateFormatter(requestEvent.getSystemCreationDate());
        addProperty(document, EVENT_INITIATION, initiationDate != null ? initiationDate + " (UTC)" : "", keyFont, valueFont);

        List<SpecialInstructionsEntity> instructions = specialInstructionsRepository
                .findByEventIdOrderByCreatedOnDesc(requestEvent.getId());

        if (instructions != null && !instructions.isEmpty()) {
            Paragraph headerParagraph = new Paragraph(SPECIAL_INSTRUCTION, valueFont);
            headerParagraph.setAlignment(Element.ALIGN_CENTER);
            headerParagraph.setSpacingAfter(5f);
            document.add(headerParagraph);
            createTwoColumnInstructions(document, writer, instructions, keyFont);
        }

        document.close();
        return byteArrayOutputStream.toByteArray();
    }

    private void addProperty(Document document, String key, String value, Font keyFont, Font valueFont) throws DocumentException {
        Paragraph paragraph = new Paragraph();
        paragraph.add(new Chunk(key, keyFont));
        paragraph.add(new Chunk(Objects.toString(value, ""), valueFont));
        paragraph.setSpacingAfter(Float.parseFloat(betweenProperties));
        paragraph.setAlignment(Integer.parseInt(alignmentLeft));
        document.add(paragraph);
    }

    private List<String> breakCommentIntoChunks(String comment) {
        List<String> chunks = new ArrayList<>();
        if (comment == null || comment.isEmpty()) {
            chunks.add("");
            return chunks;
        }
        if (comment.length() <= MAX_COMMENT_LENGTH) {
            chunks.add(comment);
            return chunks;
        }

        int startIndex = 0;
        while (startIndex < comment.length()) {
            int endIndex = Math.min(startIndex + CHUNK_SIZE, comment.length());
            if (endIndex < comment.length()) {
                int lastSpace = comment.lastIndexOf(' ', endIndex);
                int lastPeriod = comment.lastIndexOf('.', endIndex);
                int lastComma = comment.lastIndexOf(',', endIndex);
                int breakPoint = Math.max(lastPeriod, Math.max(lastSpace, lastComma));
                if (breakPoint > startIndex + (CHUNK_SIZE / 2)) {
                    endIndex = breakPoint + 1;
                }
            }
            chunks.add(comment.substring(startIndex, endIndex).trim());
            startIndex = endIndex;
        }
        return chunks;
    }

    private String cleanHtml(String comment) {
        return comment.replaceAll("<[^>]*>", "").trim();
    }

    private String dateFormatter(LocalDateTime dateTime) {
        if (dateTime == null) return null;
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        return dateTime.format(formatter);
    }
} "", valueFont);
        e9.add(eventInitiationKey);
        e9.add(eventInitiationValue);
        e9.setAlignment(Integer.parseInt(alignmentLeft));
        e9.setSpacingAfter(Float.valueOf(betweenProperties).floatValue());
        document.add(e9);

        // Special Instructions
        List<SpecialInstructionsEntity> instructions = specialInstructionsRepository
            .findByEventIdOrderByCreatedOnDesc(requestEvent.getId());
        
        if (instructions != null && !instructions.isEmpty()) {
            Paragraph headerParagraph = new Paragraph(SPECIAL_INSTRUCTION, valueFont);
            headerParagraph.setAlignment(Element.ALIGN_CENTER);
            headerParagraph.setSpacingAfter(5f);
            document.add(headerParagraph);

            createTwoColumnInstructions(document, writer, instructions, keyFont);
        }

        document.close();
        return byteArrayOutputStream.toByteArray();
    }

    private void createTwoColumnInstructions(Document document, PdfWriter writer, 
                                           List<SpecialInstructionsEntity> instructions, Font font) {
        float pageWidth = document.getPageSize().getWidth();
        float pageHeight = document.getPageSize().getHeight();
        float left = document.leftMargin();
        float right = document.rightMargin();
        float top = document.topMargin();
        float bottom = document.bottomMargin();
        float COLUMN_GAP = 20f;
        float usableWidth = pageWidth - left - right;
        float columnWidth = (usableWidth - COLUMN_GAP) / 2;
        float yStart = pageHeight - top - 100;

        try {
            float currentY = writer.getVerticalPosition(true);
            if (currentY > 0 && currentY < yStart) {
                yStart = currentY - 20;
            }
        } catch (Exception e) {
            // Use default yStart if there's an error getting current position
            System.err.println("Error getting vertical position: " + e.getMessage());
        }

        float yEnd = bottom + 50; // Add some margin from bottom
        List<Paragraph> paragraphs = buildInstructionParagraphs(instructions, font, writer);
        int instructionIndex = 0;
        int maxPages = 50; // Safety limit to prevent infinite loops
        int pageCount = 0;

        while (instructionIndex < paragraphs.size() && pageCount < maxPages) {
            try {
                ColumnText leftColumn = new ColumnText(writer.getDirectContent());
                ColumnText rightColumn = new ColumnText(writer.getDirectContent());

                // Set up columns with proper boundaries
                leftColumn.setSimpleColumn(left, yEnd, left + columnWidth, yStart);
                rightColumn.setSimpleColumn(left + columnWidth + COLUMN_GAP, yEnd, 
                                          left + 2 * columnWidth + COLUMN_GAP, yStart);

                // Set text leading (line spacing) to prevent text overlap
                leftColumn.setLeading(14f);
                rightColumn.setLeading(14f);

                // Fill left column
                int prevIndex = instructionIndex;
                instructionIndex = fillColumn(leftColumn, paragraphs, instructionIndex);
                
                // Fill right column if there are more paragraphs
                if (instructionIndex < paragraphs.size()) {
                    instructionIndex = fillColumn(rightColumn, paragraphs, instructionIndex);
                }

                // Safety check to prevent infinite loops
                if (instructionIndex == prevIndex) {
                    System.err.println("No progress made, skipping remaining content");
                    break;
                }

                // Add new page if more content remains
                if (instructionIndex < paragraphs.size()) {
                    document.newPage();
                    yStart = pageHeight - top;
                    pageCount++;
                }
                
            } catch (Exception e) {
                System.err.println("Error creating columns on page " + (pageCount + 1) + ": " + e.getMessage());
                // Try to recover by moving to next page
                if (instructionIndex < paragraphs.size()) {
                    document.newPage();
                    yStart = pageHeight - top;
                    pageCount++;
                    // Skip problematic content if we can't recover
                    if (pageCount > 3) { // Allow a few retries
                        instructionIndex++; // Skip current problematic paragraph
                    }
                }
            }
        }

        if (pageCount >= maxPages) {
            System.err.println("Maximum page limit reached. Some content may have been skipped.");
        }
    }

    private int fillColumn(ColumnText column, List<Paragraph> paragraphs, int startIndex) {
        column.setText(null);
        int currentIndex = startIndex;

        while (currentIndex < paragraphs.size()) {
            // Create a test column to check if content fits
            ColumnText testColumn = ColumnText.duplicate(column);
            
            // Add current paragraph to test column
            testColumn.addElement(paragraphs.get(currentIndex));
            
            try {
                int status = testColumn.go(true); // Simulate mode
                
                if (ColumnText.hasMoreText(status)) {
                    // Content doesn't fit, break here
                    break;
                } else {
                    // Content fits, add to actual column
                    column.addElement(paragraphs.get(currentIndex));
                    currentIndex++;
                }
            } catch (Exception e) {
                // If there's an error with the test, try adding anyway
                // This prevents blocking on problematic content
                try {
                    column.addElement(paragraphs.get(currentIndex));
                    currentIndex++;
                } catch (Exception addError) {
                    // If adding fails, skip this paragraph and continue
                    System.err.println("Skipping problematic paragraph: " + addError.getMessage());
                    currentIndex++;
                    break;
                }
            }
        }

        try {
            column.go(); // Render the column
        } catch (Exception e) {
            System.err.println("Error rendering column: " + e.getMessage());
        }
        
        return currentIndex;
    }

    private List<Paragraph> buildInstructionParagraphs(List<SpecialInstructionsEntity> instructions, 
                                                       Font font, PdfWriter writer) {
        List<Paragraph> list = new ArrayList<>();
        int count = 1;

        for (SpecialInstructionsEntity instruction : instructions) {
            String createdOn = instruction.getCreatedOn() != null ? 
                dateFormatter(instruction.getCreatedOn()) : "";
            String createdBy = instruction.getCreatedByUser() != null ? 
                instruction.getCreatedByUser() : "";
            String comment = instruction.getComment() != null ? 
                cleanHtml(instruction.getComment()) : "";

            // Handle long comments by breaking them into chunks
            List<String> commentChunks = breakCommentIntoChunks(comment);
            
            for (int i = 0; i < commentChunks.size(); i++) {
                String chunk = commentChunks.get(i);
                String line;
                
                if (i == 0) {
                    // First chunk includes the header
                    line = String.format("[%s] [%s]\n%d) %s", createdOn, createdBy, count, chunk);
                } else {
                    // Subsequent chunks are continuation
                    line = String.format("   (continued...) %s", chunk);
                }

                Paragraph p = new Paragraph(line, font);
                p.setSpacingAfter(i == commentChunks.size() - 1 ? 15f : 8f); // Less spacing for continuations
                p.setIndentationLeft(5f);
                p.setKeepTogether(false); // Allow breaking across pages for long content
                
                // Only set alignment for non-continuation paragraphs
                if (i == 0) {
                    p.setAlignment(Element.ALIGN_LEFT);
                }
                
                list.add(p);
            }
            count++;
        }

        return list;
    }

    private List<String> breakCommentIntoChunks(String comment) {
        List<String> chunks = new ArrayList<>();
        
        if (comment == null || comment.isEmpty()) {
            chunks.add("");
            return chunks;
        }
        
        // If comment is within limit, return as single chunk
        if (comment.length() <= MAX_COMMENT_LENGTH) {
            chunks.add(comment);
            return chunks;
        }
        
        // Break into smaller chunks for better handling
        int startIndex = 0;
        
        while (startIndex < comment.length()) {
            int endIndex = Math.min(startIndex + CHUNK_SIZE, comment.length());
            
            // Try to break at word boundary if possible
            if (endIndex < comment.length()) {
                int lastSpace = comment.lastIndexOf(' ', endIndex);
                int lastPeriod = comment.lastIndexOf('.', endIndex);
                int lastComma = comment.lastIndexOf(',', endIndex);
                
                // Find the best break point (prefer period, then space, then comma)
                int breakPoint = Math.max(lastPeriod, Math.max(lastSpace, lastComma));
                
                if (breakPoint > startIndex + (CHUNK_SIZE / 2)) { // Only use if it's reasonable
                    endIndex = breakPoint + 1; // Include the punctuation/space
                }
            }
            
            String chunk = comment.substring(startIndex, endIndex).trim();
            if (!chunk.isEmpty()) {
                chunks.add(chunk);
            }
            
            startIndex = endIndex;
        }
        
        return chunks;
    }

    private String truncateComment(String comment) {
        if (comment == null || comment.length() <= MAX_COMMENT_LENGTH) {
            return comment;
        }
        
        // Truncate and add ellipsis
        return comment.substring(0, MAX_COMMENT_LENGTH - 3) + "...";
    }

    private String cleanHtml(String input) {
        return input.replaceAll("<[^>]*>", "")
                   .replaceAll("&nbsp;", " ")
                   .replaceAll("&amp;", "&")
                   .replaceAll("&lt;", "<")
                   .replaceAll("&gt;", ">")
                   .replaceAll("&quot;", "\"")
                   .trim();
    }

    private String dateFormatter(LocalDateTime dt) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("d'th' MMMM yyyy HH:mm");
        return dt.format(formatter);
    }
}
