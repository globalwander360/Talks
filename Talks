import com.bnpparibas.dpw.service.CxtProdCodeServiceImpl;
import com.bnpparibas.dpe.referential.model.CxtProdCode;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.*;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

public class CxtProdCodeServiceImplTest {

    @Mock
    private ReferentialUtil referentialUtil;

    @InjectMocks
    private CxtProdCodeServiceImpl cxtProdCodeService;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testGetCxTProdCodeName_ReturnsCorrectMap() {
        String bnppuid = "BNPP123";

        CxtProdCode code1 = new CxtProdCode();
        code1.setProdCode("P001");
        code1.setProdCodeName("Product 1");

        CxtProdCode code2 = new CxtProdCode();
        code2.setProdCode("P002");
        code2.setProdCodeName("Product 2");

        List<CxtProdCode> mockList = Arrays.asList(code1, code2);

        when(referentialUtil.getCxtProdCode(bnppuid)).thenReturn(mockList);

        Map<String, String> result = cxtProdCodeService.getCxTProdCodeName(bnppuid);

        Map<String, String> expected = new HashMap<>();
        expected.put("P001", "Product 1");
        expected.put("P002", "Product 2");

        assertEquals(expected, result);
    }
}



import com.bnpparibas.dpw.service.CxtProdCodeServiceImpl;
import com.bnpparibas.dpe.referential.model.CxtProdCode;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.*;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

public class CxtProdCodeServiceImplTest {

    @Mock
    private ReferentialUtil referentialUtil;

    @InjectMocks
    private CxtProdCodeServiceImpl cxtProdCodeService;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testGetCxTProdCodeName_ReturnsCorrectMap() {
        String bnppuid = "BNPP001";

        CxtProdCode code1 = new CxtProdCode();
        code1.setProdCode("P001");
        code1.setProdCodeName("Product 1");

        CxtProdCode code2 = new CxtProdCode();
        code2.setProdCode("P002");
        code2.setProdCodeName("Product 2");

        List<CxtProdCode> mockList = Arrays.asList(code1, code2);

        when(referentialUtil.getCxtProdCode(bnppuid)).thenReturn(mockList);

        Map<String, String> expected = new HashMap<>();
        expected.put("P001", "Product 1");
        expected.put("P002", "Product 2");

        Map<String, String> result = cxtProdCodeService.getCxTProdCodeName(bnppuid);

        assertEquals(expected, result);
    }

    @Test
    public void testGetCxTProdCodeName_EmptyList() {
        String bnppuid = "BNPP002";

        when(referentialUtil.getCxtProdCode(bnppuid)).thenReturn(Collections.emptyList());

        Map<String, String> result = cxtProdCodeService.getCxTProdCodeName(bnppuid);

        assertEquals(Collections.emptyMap(), result);
    }

    @Test
    public void testGetCxTProdCodeName_DuplicateKeys() {
        String bnppuid = "BNPP003";

        CxtProdCode code1 = new CxtProdCode();
        code1.setProdCode("P001");
        code1.setProdCodeName("Product A");

        CxtProdCode code2 = new CxtProdCode();
        code2.setProdCode("P001");  // duplicate key
        code2.setProdCodeName("Product B");

        List<CxtProdCode> mockList = Arrays.asList(code1, code2);

        // To simulate resolution of duplicate keys, we assume the implementation is unchanged,
        // but in real scenarios, you should handle the duplicate key issue explicitly.
        when(referentialUtil.getCxtProdCode(bnppuid)).thenReturn(mockList);

        // This will throw IllegalStateException unless handled using merge function in Collectors.toMap.
        try {
            cxtProdCodeService.getCxTProdCodeName(bnppuid);
        } catch (IllegalStateException ex) {
            assertEquals("Duplicate key P001 (attempted merging values Product A and Product B)", ex.getMessage());
        }
    }
}
