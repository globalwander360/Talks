package com.bnpparibas.dpw.helpers;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import com.bnpparibas.dpw.entity.dpw.SpecialInstructionsEntity;
import com.bnpparibas.dpw.repository.SpecialInstructionsRepository;
import com.lowagie.text.Element;
import com.lowagie.text.pdf.ColumnText;
import com.lowagie.text.pdf.PdfContentByte;
import com.lowagie.text.pdf.PdfPageEventHelper;
import org.dom4j.DocumentException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import com.bnpparibas.dpw.controller.model.RequestEvent;
import com.lowagie.text.Chunk;
import com.lowagie.text.Document;
import com.lowagie.text.Font;
import com.lowagie.text.FontFactory;
import com.lowagie.text.PageSize;
import com.lowagie.text.Paragraph;
import com.lowagie.text.pdf.PdfWriter;

@Component
public class DpwEventPdfExporter {

    private static final String MFR = "MFR: ";
    private static final String UMFR = "UMFR: ";
    private static final String EVENTID = "Conserto Event ID: ";
    private static final String CUSTOMER_NAME = "Customer Name: ";
    private static final String CUSTOMER_ID = "Customer ID: ";
    private static final String PRODUCT_GROUP = "Product Group: ";
    private static final String PRODUCT = "Product: ";
    private static final String EVENT = "Event: ";
    private static final String EVENT_PRIORITY = "Event priority: ";
    private static final String EVENT_INITIATION = "Event Initiation: ";
    private static final String SPECIAL_INSTRUCTION = "Special Instruction: ";

    // Limits
    private static final int MAX_HEADER_VALUE_LENGTH = 50;
    private static final int MAX_COMMENT_LENGTH = 1200;
    private static final int CHUNK_SIZE = 400;
    private static final String MASK_SUFFIX = "***";

    @Value("${event.coversheet.spacing.betweenproperties}")
    private String betweenProperties;

    @Value("${event.coversheet.spacing.afterheader}")
    private String afterHeader;

    @Value("${event.coversheet.spacing.beforefooter}")
    private String beforeFooter;

    @Value("${event.coversheet.spacing.betweenparagraph}")
    private String betweenParagraph;

    @Value("${event.coversheet.font.keysize}")
    private String keySize;

    @Value("${event.coversheet.font.valuesize}")
    private String valueSize;

    @Value("${event.coversheet.font.keyfont}")
    private String keyFontProp;

    @Value("${event.coversheet.font.valuefont}")
    private String valueFontProp;

    @Value("${event.coversheet.alignment.left}")
    private String alignmentLeft;

    @Value("${event.coversheet.alignment.right}")
    private String alignmentRight;

    @Value("${event.coversheet.alignment.bottom}")
    private String alignmentBottom;

    @Autowired
    private SpecialInstructionsRepository specialInstructionsRepository;

    private class HeaderFooter extends PdfPageEventHelper {
        private RequestEvent requestEvent;
        private Font keyFont;
        private Font valueFont;

        public HeaderFooter(RequestEvent requestEvent, Font keyFont, Font valueFont) {
            this.requestEvent = requestEvent;
            this.keyFont = keyFont;
            this.valueFont = valueFont;
        }

        @Override
        public void onEndPage(PdfWriter writer, Document document) {
            PdfContentByte cb = writer.getDirectContent();
            float rightX = document.right();
            float headerY = document.getPageSize().getHeight() - 30;
            float lineSpacing = 22f;
            float availableWidth = document.right() - document.left();

            headerY = drawHeaderField(cb, MFR, maskValue(getOrDefault(requestEvent.getMfr())),
                    keyFont, valueFont, rightX, headerY, availableWidth);

            headerY = drawHeaderField(cb, UMFR, maskValue(getOrDefault(requestEvent.getUmfr())),
                    keyFont, valueFont, rightX, headerY - lineSpacing, availableWidth);

            headerY = drawHeaderField(cb, EVENTID, maskValue(getOrDefault(requestEvent.getId())),
                    keyFont, valueFont, rightX, headerY - lineSpacing, availableWidth);

            headerY = drawHeaderField(cb, CUSTOMER_ID, maskValue(getOrDefault(requestEvent.getCustId())),
                    keyFont, valueFont, rightX, headerY - lineSpacing, availableWidth);

            headerY = drawHeaderField(cb, CUSTOMER_NAME, maskValue(getOrDefault(requestEvent.getCusName())),
                    keyFont, valueFont, rightX, headerY - lineSpacing, availableWidth);
        }

        private float drawHeaderField(PdfContentByte cb, String label, String value, Font keyFont,
                                      Font valueFont, float rightX, float y, float availableWidth) {

            float labelWidth = keyFont.getBaseFont().getWidthPoint(label, keyFont.getSize());
            float valueWidth = valueFont.getBaseFont().getWidthPoint(value, valueFont.getSize());
            float totalWidth = labelWidth + valueWidth;

            if (totalWidth <= availableWidth) {
                float startX = rightX - totalWidth;
                drawText(cb, label, keyFont, startX, y);
                drawText(cb, value, valueFont, startX + labelWidth, y);
                return y;
            } else {
                float labelStartX = rightX - labelWidth;
                drawText(cb, label, keyFont, labelStartX, y);
                float valueY = y - 15f;
                drawText(cb, value, valueFont, document.left(), valueY);
                return valueY;
            }
        }

        private void drawText(PdfContentByte cb, String text, Font font, float x, float y) {
            cb.beginText();
            cb.setFontAndSize(font.getBaseFont(), font.getSize());
            cb.setTextMatrix(x, y);
            cb.showText(text);
            cb.endText();
        }

        private String maskValue(String value) {
            if (value == null || value.equals("-") || value.length() <= MAX_HEADER_VALUE_LENGTH) {
                return value;
            }
            int visibleLength = MAX_HEADER_VALUE_LENGTH - MASK_SUFFIX.length();
            return value.substring(0, visibleLength) + MASK_SUFFIX;
        }

        private String getOrDefault(String str) {
            return (str == null || str.trim().isEmpty()) ? "-" : str;
        }
    }

    public byte[] export(RequestEvent requestEvent) throws DocumentException, IOException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        Document document = new Document(PageSize.A4);
        document.setMargins(36, 36, 140, 36);

        PdfWriter writer = PdfWriter.getInstance(document, byteArrayOutputStream);

        Font keyFont = FontFactory.getFont(keyFontProp);
        keyFont.setSize(Float.parseFloat(keySize));

        Font valueFont = FontFactory.getFont(valueFontProp);
        valueFont.setSize(Float.parseFloat(valueSize));

        writer.setPageEvent(new HeaderFooter(requestEvent, keyFont, valueFont));

        document.open();

        addProperty(document, PRODUCT_GROUP, requestEvent.getProductGroupName(), keyFont, valueFont);
        addProperty(document, PRODUCT, requestEvent.getProductName(), keyFont, valueFont);
        addProperty(document, EVENT, requestEvent.getEventName(), keyFont, valueFont);
        addProperty(document, EVENT_PRIORITY, requestEvent.getEventPriorityName(), keyFont, valueFont);

        String initiationDate = dateFormatter(requestEvent.getSystemCreationDate());
        addProperty(document, EVENT_INITIATION, initiationDate != null ? initiationDate + " (UTC)" : "", keyFont, valueFont);

        List<SpecialInstructionsEntity> instructions = specialInstructionsRepository
                .findByEventIdOrderByCreatedOnDesc(requestEvent.getId());

        if (instructions != null && !instructions.isEmpty()) {
            Paragraph headerParagraph = new Paragraph(SPECIAL_INSTRUCTION, valueFont);
            headerParagraph.setAlignment(Element.ALIGN_CENTER);
            headerParagraph.setSpacingAfter(5f);
            document.add(headerParagraph);
            createTwoColumnInstructions(document, writer, instructions, keyFont);
        }

        document.close();
        return byteArrayOutputStream.toByteArray();
    }

    private void addProperty(Document document, String key, String value, Font keyFont, Font valueFont) throws DocumentException {
        Paragraph paragraph = new Paragraph();
        paragraph.add(new Chunk(key, keyFont));
        paragraph.add(new Chunk(Objects.toString(value, ""), valueFont));
        paragraph.setSpacingAfter(Float.parseFloat(betweenProperties));
        paragraph.setAlignment(Integer.parseInt(alignmentLeft));
        document.add(paragraph);
    }

    private List<String> breakCommentIntoChunks(String comment) {
        List<String> chunks = new ArrayList<>();
        if (comment == null || comment.isEmpty()) {
            chunks.add("");
            return chunks;
        }
        if (comment.length() <= MAX_COMMENT_LENGTH) {
            chunks.add(comment);
            return chunks;
        }

        int startIndex = 0;
        while (startIndex < comment.length()) {
            int endIndex = Math.min(startIndex + CHUNK_SIZE, comment.length());
            if (endIndex < comment.length()) {
                int lastSpace = comment.lastIndexOf(' ', endIndex);
                int lastPeriod = comment.lastIndexOf('.', endIndex);
                int lastComma = comment.lastIndexOf(',', endIndex);
                int breakPoint = Math.max(lastPeriod, Math.max(lastSpace, lastComma));
                if (breakPoint > startIndex + (CHUNK_SIZE / 2)) {
                    endIndex = breakPoint + 1;
                }
            }
            chunks.add(comment.substring(startIndex, endIndex).trim());
            startIndex = endIndex;
        }
        return chunks;
    }

    private String cleanHtml(String comment) {
        return comment.replaceAll("<[^>]*>", "").trim();
    }

    private String dateFormatter(LocalDateTime dateTime) {
        if (dateTime == null) return null;
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        return dateTime.format(formatter);
    }
} "", valueFont);
        e9.add(eventInitiationKey);
        e9.add(eventInitiationValue);
        e9.setAlignment(Integer.parseInt(alignmentLeft));
        e9.setSpacingAfter(Float.valueOf(betweenProperties).floatValue());
        document.add(e9);

        // Special Instructions
        List<SpecialInstructionsEntity> instructions = specialInstructionsRepository
            .findByEventIdOrderByCreatedOnDesc(requestEvent.getId());
        
        if (instructions != null && !instructions.isEmpty()) {
            Paragraph headerParagraph = new Paragraph(SPECIAL_INSTRUCTION, valueFont);
            headerParagraph.setAlignment(Element.ALIGN_CENTER);
            headerParagraph.setSpacingAfter(5f);
            document.add(headerParagraph);

            createTwoColumnInstructions(document, writer, instructions, keyFont);
        }

        document.close();
        return byteArrayOutputStream.toByteArray();
    }

    private void createTwoColumnInstructions(Document document, PdfWriter writer, 
                                           List<SpecialInstructionsEntity> instructions, Font font) {
        float pageWidth = document.getPageSize().getWidth();
        float pageHeight = document.getPageSize().getHeight();
        float left = document.leftMargin();
        float right = document.rightMargin();
        float top = document.topMargin();
        float bottom = document.bottomMargin();
        float COLUMN_GAP = 20f;
        float usableWidth = pageWidth - left - right;
        float columnWidth = (usableWidth - COLUMN_GAP) / 2;
        float yStart = pageHeight - top - 100;

        try {
            float currentY = writer.getVerticalPosition(true);
            if (currentY > 0 && currentY < yStart) {
                yStart = currentY - 20;
            }
        } catch (Exception e) {
            // Use default yStart if there's an error getting current position
            System.err.println("Error getting vertical position: " + e.getMessage());
        }

        float yEnd = bottom + 50; // Add some margin from bottom
        List<Paragraph> paragraphs = buildInstructionParagraphs(instructions, font, writer);
        int instructionIndex = 0;
        int maxPages = 50; // Safety limit to prevent infinite loops
        int pageCount = 0;

        while (instructionIndex < paragraphs.size() && pageCount < maxPages) {
            try {
                ColumnText leftColumn = new ColumnText(writer.getDirectContent());
                ColumnText rightColumn = new ColumnText(writer.getDirectContent());

                // Set up columns with proper boundaries
                leftColumn.setSimpleColumn(left, yEnd, left + columnWidth, yStart);
                rightColumn.setSimpleColumn(left + columnWidth + COLUMN_GAP, yEnd, 
                                          left + 2 * columnWidth + COLUMN_GAP, yStart);

                // Set text leading (line spacing) to prevent text overlap
                leftColumn.setLeading(14f);
                rightColumn.setLeading(14f);

                // Fill left column
                int prevIndex = instructionIndex;
                instructionIndex = fillColumn(leftColumn, paragraphs, instructionIndex);
                
                // Fill right column if there are more paragraphs
                if (instructionIndex < paragraphs.size()) {
                    instructionIndex = fillColumn(rightColumn, paragraphs, instructionIndex);
                }

                // Safety check to prevent infinite loops
                if (instructionIndex == prevIndex) {
                    System.err.println("No progress made, skipping remaining content");
                    break;
                }

                // Add new page if more content remains
                if (instructionIndex < paragraphs.size()) {
                    document.newPage();
                    yStart = pageHeight - top;
                    pageCount++;
                }
                
            } catch (Exception e) {
                System.err.println("Error creating columns on page " + (pageCount + 1) + ": " + e.getMessage());
                // Try to recover by moving to next page
                if (instructionIndex < paragraphs.size()) {
                    document.newPage();
                    yStart = pageHeight - top;
                    pageCount++;
                    // Skip problematic content if we can't recover
                    if (pageCount > 3) { // Allow a few retries
                        instructionIndex++; // Skip current problematic paragraph
                    }
                }
            }
        }

        if (pageCount >= maxPages) {
            System.err.println("Maximum page limit reached. Some content may have been skipped.");
        }
    }

    private int fillColumn(ColumnText column, List<Paragraph> paragraphs, int startIndex) {
        column.setText(null);
        int currentIndex = startIndex;

        while (currentIndex < paragraphs.size()) {
            // Create a test column to check if content fits
            ColumnText testColumn = ColumnText.duplicate(column);
            
            // Add current paragraph to test column
            testColumn.addElement(paragraphs.get(currentIndex));
            
            try {
                int status = testColumn.go(true); // Simulate mode
                
                if (ColumnText.hasMoreText(status)) {
                    // Content doesn't fit, break here
                    break;
                } else {
                    // Content fits, add to actual column
                    column.addElement(paragraphs.get(currentIndex));
                    currentIndex++;
                }
            } catch (Exception e) {
                // If there's an error with the test, try adding anyway
                // This prevents blocking on problematic content
                try {
                    column.addElement(paragraphs.get(currentIndex));
                    currentIndex++;
                } catch (Exception addError) {
                    // If adding fails, skip this paragraph and continue
                    System.err.println("Skipping problematic paragraph: " + addError.getMessage());
                    currentIndex++;
                    break;
                }
            }
        }

        try {
            column.go(); // Render the column
        } catch (Exception e) {
            System.err.println("Error rendering column: " + e.getMessage());
        }
        
        return currentIndex;
    }

    private List<Paragraph> buildInstructionParagraphs(List<SpecialInstructionsEntity> instructions, 
                                                       Font font, PdfWriter writer) {
        List<Paragraph> list = new ArrayList<>();
        int count = 1;

        for (SpecialInstructionsEntity instruction : instructions) {
            String createdOn = instruction.getCreatedOn() != null ? 
                dateFormatter(instruction.getCreatedOn()) : "";
            String createdBy = instruction.getCreatedByUser() != null ? 
                instruction.getCreatedByUser() : "";
            String comment = instruction.getComment() != null ? 
                cleanHtml(instruction.getComment()) : "";

            // Handle long comments by breaking them into chunks
            List<String> commentChunks = breakCommentIntoChunks(comment);
            
            for (int i = 0; i < commentChunks.size(); i++) {
                String chunk = commentChunks.get(i);
                String line;
                
                if (i == 0) {
                    // First chunk includes the header
                    line = String.format("[%s] [%s]\n%d) %s", createdOn, createdBy, count, chunk);
                } else {
                    // Subsequent chunks are continuation
                    line = String.format("   (continued...) %s", chunk);
                }

                Paragraph p = new Paragraph(line, font);
                p.setSpacingAfter(i == commentChunks.size() - 1 ? 15f : 8f); // Less spacing for continuations
                p.setIndentationLeft(5f);
                p.setKeepTogether(false); // Allow breaking across pages for long content
                
                // Only set alignment for non-continuation paragraphs
                if (i == 0) {
                    p.setAlignment(Element.ALIGN_LEFT);
                }
                
                list.add(p);
            }
            count++;
        }

        return list;
    }

    private List<String> breakCommentIntoChunks(String comment) {
        List<String> chunks = new ArrayList<>();
        
        if (comment == null || comment.isEmpty()) {
            chunks.add("");
            return chunks;
        }
        
        // If comment is within limit, return as single chunk
        if (comment.length() <= MAX_COMMENT_LENGTH) {
            chunks.add(comment);
            return chunks;
        }
        
        // Break into smaller chunks for better handling
        int startIndex = 0;
        
        while (startIndex < comment.length()) {
            int endIndex = Math.min(startIndex + CHUNK_SIZE, comment.length());
            
            // Try to break at word boundary if possible
            if (endIndex < comment.length()) {
                int lastSpace = comment.lastIndexOf(' ', endIndex);
                int lastPeriod = comment.lastIndexOf('.', endIndex);
                int lastComma = comment.lastIndexOf(',', endIndex);
                
                // Find the best break point (prefer period, then space, then comma)
                int breakPoint = Math.max(lastPeriod, Math.max(lastSpace, lastComma));
                
                if (breakPoint > startIndex + (CHUNK_SIZE / 2)) { // Only use if it's reasonable
                    endIndex = breakPoint + 1; // Include the punctuation/space
                }
            }
            
            String chunk = comment.substring(startIndex, endIndex).trim();
            if (!chunk.isEmpty()) {
                chunks.add(chunk);
            }
            
            startIndex = endIndex;
        }
        
        return chunks;
    }

    private String truncateComment(String comment) {
        if (comment == null || comment.length() <= MAX_COMMENT_LENGTH) {
            return comment;
        }
        
        // Truncate and add ellipsis
        return comment.substring(0, MAX_COMMENT_LENGTH - 3) + "...";
    }

    private String cleanHtml(String input) {
        return input.replaceAll("<[^>]*>", "")
                   .replaceAll("&nbsp;", " ")
                   .replaceAll("&amp;", "&")
                   .replaceAll("&lt;", "<")
                   .replaceAll("&gt;", ">")
                   .replaceAll("&quot;", "\"")
                   .trim();
    }

    private String dateFormatter(LocalDateTime dt) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("d'th' MMMM yyyy HH:mm");
        return dt.format(formatter);
    }
}
